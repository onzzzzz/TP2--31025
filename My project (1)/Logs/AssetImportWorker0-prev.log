Unity Editor version:    2021.3.24f1 (cf10dcf7010d)
Branch:                  2021.3/staging
Build type:              Release
Batch mode:              YES
macOS version:           Version 10.13.6 (Build 17G14042)
Darwin version:          17.7.0
Architecture:            x86_64
Running under Rosetta:   NO
Available memory:        4096 MB
Using pre-set license
Pro License: YES

COMMAND LINE ARGUMENTS:
/Applications/Unity/Hub/Editor/2021.3.24f1/Unity.app/Contents/MacOS/Unity
-adb2
-batchMode
-noUpm
-name
AssetImportWorker0
-projectPath
/Users/ninatchernega/Desktop/my game/My project (1)
-logFile
Logs/AssetImportWorker0.log
-srvPort
61352
Successfully changed project path to: /Users/ninatchernega/Desktop/my game/My project (1)
/Users/ninatchernega/Desktop/my game/My project (1)
[UnityMemory] Configuration Parameters - Can be set up in boot.config
    "memorysetup-bucket-allocator-granularity=16"
    "memorysetup-bucket-allocator-bucket-count=8"
    "memorysetup-bucket-allocator-block-size=33554432"
    "memorysetup-bucket-allocator-block-count=8"
    "memorysetup-main-allocator-block-size=16777216"
    "memorysetup-thread-allocator-block-size=16777216"
    "memorysetup-gfx-main-allocator-block-size=16777216"
    "memorysetup-gfx-thread-allocator-block-size=16777216"
    "memorysetup-cache-allocator-block-size=4194304"
    "memorysetup-typetree-allocator-block-size=2097152"
    "memorysetup-profiler-bucket-allocator-granularity=16"
    "memorysetup-profiler-bucket-allocator-bucket-count=8"
    "memorysetup-profiler-bucket-allocator-block-size=33554432"
    "memorysetup-profiler-bucket-allocator-block-count=8"
    "memorysetup-profiler-allocator-block-size=16777216"
    "memorysetup-profiler-editor-allocator-block-size=1048576"
    "memorysetup-temp-allocator-size-main=16777216"
    "memorysetup-job-temp-allocator-block-size=2097152"
    "memorysetup-job-temp-allocator-block-size-background=1048576"
    "memorysetup-job-temp-allocator-reduction-small-platforms=262144"
    "memorysetup-temp-allocator-size-background-worker=32768"
    "memorysetup-temp-allocator-size-job-worker=262144"
    "memorysetup-temp-allocator-size-preload-manager=33554432"
    "memorysetup-temp-allocator-size-nav-mesh-worker=65536"
    "memorysetup-temp-allocator-size-audio-worker=65536"
    "memorysetup-temp-allocator-size-cloud-worker=32768"
    "memorysetup-temp-allocator-size-gi-baking-worker=262144"
    "memorysetup-temp-allocator-size-gfx=262144"
Player connection [140736129713024] Host "[IP] 192.168.1.64 [Port] 0 [Flags] 2 [Guid] 4247842985 [EditorId] 4247842985 [Version] 1048832 [Id] OSXEditor(0,Nina-Air.Home) [Debug] 1 [PackageName] OSXEditor [ProjectName] Editor" joined multi-casting on [225.0.0.222:54997]...

Player connection [140736129713024] Host "[IP] 192.168.1.64 [Port] 0 [Flags] 2 [Guid] 4247842985 [EditorId] 4247842985 [Version] 1048832 [Id] OSXEditor(0,Nina-Air.Home) [Debug] 1 [PackageName] OSXEditor [ProjectName] Editor" joined alternative multi-casting on [225.0.0.222:34997]...

Refreshing native plugins compatible for Editor in 678.26 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Initialize engine version: 2021.3.24f1 (cf10dcf7010d)
[Subsystems] Discovering subsystems at path /Applications/Unity/Hub/Editor/2021.3.24f1/Unity.app/Contents/Resources/UnitySubsystems
[Subsystems] Discovering subsystems at path /Users/ninatchernega/Desktop/my game/My project (1)/Assets
GfxDevice: creating device client; threaded=0; jobified=0
Color LCD preferred device: Intel HD Graphics 4000 (low power)
Metal devices available: 1
0: Intel HD Graphics 4000 (low power)
Using device Intel HD Graphics 4000 (low power)
Initializing Metal device caps: Intel HD Graphics 4000
Initialize mono
Mono path[0] = '/Applications/Unity/Hub/Editor/2021.3.24f1/Unity.app/Contents/Managed'
Mono path[1] = '/Applications/Unity/Hub/Editor/2021.3.24f1/Unity.app/Contents/MonoBleedingEdge/lib/mono/unityjit-macos'
Mono config path = '/Applications/Unity/Hub/Editor/2021.3.24f1/Unity.app/Contents/MonoBleedingEdge/etc'
Using monoOptions --debugger-agent=transport=dt_socket,embedding=1,server=y,suspend=n,address=127.0.0.1:56947
Begin MonoManager ReloadAssembly
Registering precompiled unity dll's ...
Register platform support module: /Applications/Unity/Hub/Editor/2021.3.24f1/PlaybackEngines/WebGLSupport/UnityEditor.WebGL.Extensions.dll
Register platform support module: /Applications/Unity/Hub/Editor/2021.3.24f1/Unity.app/Contents/PlaybackEngines/MacStandaloneSupport/UnityEditor.OSXStandalone.Extensions.dll
Registered in 0.007086 seconds.
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 337.28 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.532 seconds
Domain Reload Profiling:
	ReloadAssembly (2534ms)
		BeginReloadAssembly (507ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (0ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (4ms)
		EndReloadAssembly (1714ms)
			LoadAssemblies (514ms)
			RebuildTransferFunctionScriptingTraits (8ms)
			SetupTypeCache (426ms)
			ReleaseScriptCaches (0ms)
			RebuildScriptCaches (115ms)
			SetupLoadedEditorAssemblies (1000ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (35ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (337ms)
				BeforeProcessingInitializeOnLoad (5ms)
				ProcessInitializeOnLoadAttributes (471ms)
				ProcessInitializeOnLoadMethodAttributes (149ms)
				AfterProcessingInitializeOnLoad (0ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (0ms)
Platform modules already initialized, skipping
Registering precompiled user dll's ...
Registered in 0.018781 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.79 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  3.520 seconds
Domain Reload Profiling:
	ReloadAssembly (3522ms)
		BeginReloadAssembly (443ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (16ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (80ms)
		EndReloadAssembly (2785ms)
			LoadAssemblies (427ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (976ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (216ms)
			SetupLoadedEditorAssemblies (1062ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (14ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (318ms)
				ProcessInitializeOnLoadAttributes (669ms)
				ProcessInitializeOnLoadMethodAttributes (51ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
========================================================================
Worker process is ready to serve import requests
Launching external process: /Applications/Unity/Hub/Editor/2021.3.24f1/Unity.app/Contents/Tools/UnityShaderCompiler
Launched and connected shader compiler UnityShaderCompiler after 0.03 seconds
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 1.16 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3074 Unused Serialized files (Serialized files now loaded: 0)
Unloading 24 unused Assets / (88.8 KB). Loaded Objects now: 3539.
Memory consumption went from 104.9 MB to 104.8 MB.
Total: 9.530570 ms (FindLiveObjects: 0.674332 ms CreateObjectMapping: 0.461230 ms MarkObjects: 8.030944 ms  DeleteObjects: 0.361120 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004700 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.98 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  4.005 seconds
Domain Reload Profiling:
	ReloadAssembly (4007ms)
		BeginReloadAssembly (323ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (14ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (125ms)
		EndReloadAssembly (3306ms)
			LoadAssemblies (222ms)
			RebuildTransferFunctionScriptingTraits (2ms)
			SetupTypeCache (1326ms)
			ReleaseScriptCaches (4ms)
			RebuildScriptCaches (192ms)
			SetupLoadedEditorAssemblies (1246ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (24ms)
				SetLoadedEditorAssemblies (9ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (215ms)
				ProcessInitializeOnLoadAttributes (926ms)
				ProcessInitializeOnLoadMethodAttributes (64ms)
				AfterProcessingInitializeOnLoad (5ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 6.01 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.3 KB). Loaded Objects now: 3542.
Memory consumption went from 103.4 MB to 103.4 MB.
Total: 7.082382 ms (FindLiveObjects: 0.411034 ms CreateObjectMapping: 0.283478 ms MarkObjects: 5.974993 ms  DeleteObjects: 0.409113 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004885 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 2.04 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  3.557 seconds
Domain Reload Profiling:
	ReloadAssembly (3559ms)
		BeginReloadAssembly (835ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (30ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (295ms)
		EndReloadAssembly (2329ms)
			LoadAssemblies (510ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1035ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (133ms)
			SetupLoadedEditorAssemblies (733ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (22ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (189ms)
				ProcessInitializeOnLoadAttributes (470ms)
				ProcessInitializeOnLoadMethodAttributes (44ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (13ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 2.97 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.6 KB). Loaded Objects now: 3545.
Memory consumption went from 103.5 MB to 103.4 MB.
Total: 5.080520 ms (FindLiveObjects: 0.394985 ms CreateObjectMapping: 0.294917 ms MarkObjects: 4.184901 ms  DeleteObjects: 0.203564 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004174 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.72 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.905 seconds
Domain Reload Profiling:
	ReloadAssembly (2907ms)
		BeginReloadAssembly (291ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (96ms)
		EndReloadAssembly (2401ms)
			LoadAssemblies (153ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (882ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (203ms)
			SetupLoadedEditorAssemblies (960ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (13ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (180ms)
				ProcessInitializeOnLoadAttributes (686ms)
				ProcessInitializeOnLoadMethodAttributes (74ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (17ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 4.29 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3548.
Memory consumption went from 103.5 MB to 103.4 MB.
Total: 7.987946 ms (FindLiveObjects: 0.509444 ms CreateObjectMapping: 0.531501 ms MarkObjects: 6.752242 ms  DeleteObjects: 0.191848 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 312699.286833 seconds.
  path: Assets/Scripts/CollectableCount.cs
  artifactKey: Guid(0a2eabf044b114e269a1c9d4c0923515) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scripts/CollectableCount.cs using Guid(0a2eabf044b114e269a1c9d4c0923515) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '555233febdbf133255d182dbcccdb81b') in 0.354494 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004395 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.90 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  4.901 seconds
Domain Reload Profiling:
	ReloadAssembly (4946ms)
		BeginReloadAssembly (895ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (42ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (334ms)
		EndReloadAssembly (3614ms)
			LoadAssemblies (467ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1288ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (259ms)
			SetupLoadedEditorAssemblies (1440ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (17ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (282ms)
				ProcessInitializeOnLoadAttributes (1055ms)
				ProcessInitializeOnLoadMethodAttributes (76ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (20ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 5.31 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3551.
Memory consumption went from 104.5 MB to 104.4 MB.
Total: 14.046757 ms (FindLiveObjects: 0.835931 ms CreateObjectMapping: 0.647258 ms MarkObjects: 12.073520 ms  DeleteObjects: 0.486740 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004650 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.98 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.628 seconds
Domain Reload Profiling:
	ReloadAssembly (2631ms)
		BeginReloadAssembly (600ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (42ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (198ms)
		EndReloadAssembly (1810ms)
			LoadAssemblies (337ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (714ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (105ms)
			SetupLoadedEditorAssemblies (673ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (133ms)
				ProcessInitializeOnLoadAttributes (479ms)
				ProcessInitializeOnLoadMethodAttributes (43ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 3.33 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3554.
Memory consumption went from 104.5 MB to 104.4 MB.
Total: 5.173317 ms (FindLiveObjects: 0.325681 ms CreateObjectMapping: 0.349682 ms MarkObjects: 4.276508 ms  DeleteObjects: 0.219349 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005376 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.49 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  4.375 seconds
Domain Reload Profiling:
	ReloadAssembly (4378ms)
		BeginReloadAssembly (819ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (32ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (252ms)
		EndReloadAssembly (3125ms)
			LoadAssemblies (544ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1281ms)
			ReleaseScriptCaches (5ms)
			RebuildScriptCaches (195ms)
			SetupLoadedEditorAssemblies (1113ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (19ms)
				SetLoadedEditorAssemblies (3ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (193ms)
				ProcessInitializeOnLoadAttributes (810ms)
				ProcessInitializeOnLoadMethodAttributes (81ms)
				AfterProcessingInitializeOnLoad (5ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (15ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 3.56 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.6 KB). Loaded Objects now: 3557.
Memory consumption went from 104.5 MB to 104.5 MB.
Total: 9.425541 ms (FindLiveObjects: 0.559755 ms CreateObjectMapping: 0.552946 ms MarkObjects: 7.994864 ms  DeleteObjects: 0.315711 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 2109.149447 seconds.
  path: Assets/Scripts/Collectable.cs
  artifactKey: Guid(49635a36ab7b147f68c1462d7d5deefb) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scripts/Collectable.cs using Guid(49635a36ab7b147f68c1462d7d5deefb) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '37657bd3c8e19cfa05d5b74758b03772') in 0.369401 seconds 
========================================================================
Received Import Request.
  Time since last request: 395.740431 seconds.
  path: Assets/Scenes/Level 1.unity
  artifactKey: Guid(9fc0d4010bbf28b4594072e72b8655ab) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scenes/Level 1.unity using Guid(9fc0d4010bbf28b4594072e72b8655ab) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'cd846209e82ebe3e1504e491820dc7a2') in 0.005377 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004276 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.76 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.478 seconds
Domain Reload Profiling:
	ReloadAssembly (2480ms)
		BeginReloadAssembly (602ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (23ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (189ms)
		EndReloadAssembly (1668ms)
			LoadAssemblies (397ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (681ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (95ms)
			SetupLoadedEditorAssemblies (604ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (120ms)
				ProcessInitializeOnLoadAttributes (430ms)
				ProcessInitializeOnLoadMethodAttributes (39ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 3.06 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3560.
Memory consumption went from 104.5 MB to 104.5 MB.
Total: 6.353121 ms (FindLiveObjects: 0.400620 ms CreateObjectMapping: 0.415447 ms MarkObjects: 5.289768 ms  DeleteObjects: 0.245200 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004234 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.01 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  3.185 seconds
Domain Reload Profiling:
	ReloadAssembly (3188ms)
		BeginReloadAssembly (314ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (117ms)
		EndReloadAssembly (2661ms)
			LoadAssemblies (169ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1009ms)
			ReleaseScriptCaches (4ms)
			RebuildScriptCaches (194ms)
			SetupLoadedEditorAssemblies (1076ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (16ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (187ms)
				ProcessInitializeOnLoadAttributes (788ms)
				ProcessInitializeOnLoadMethodAttributes (77ms)
				AfterProcessingInitializeOnLoad (6ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (14ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 3.55 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3563.
Memory consumption went from 104.5 MB to 104.5 MB.
Total: 6.911124 ms (FindLiveObjects: 0.367656 ms CreateObjectMapping: 0.265981 ms MarkObjects: 6.067890 ms  DeleteObjects: 0.207583 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004343 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.75 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.534 seconds
Domain Reload Profiling:
	ReloadAssembly (2536ms)
		BeginReloadAssembly (555ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (23ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (202ms)
		EndReloadAssembly (1768ms)
			LoadAssemblies (343ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (719ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (102ms)
			SetupLoadedEditorAssemblies (631ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (127ms)
				ProcessInitializeOnLoadAttributes (449ms)
				ProcessInitializeOnLoadMethodAttributes (39ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (11ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 3.60 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3566.
Memory consumption went from 104.5 MB to 104.5 MB.
Total: 5.604546 ms (FindLiveObjects: 0.329576 ms CreateObjectMapping: 0.341499 ms MarkObjects: 4.679516 ms  DeleteObjects: 0.252232 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 1578.029108 seconds.
  path: Assets/Scripts/EndGame.cs
  artifactKey: Guid(faee5c32c5dc44a19b695b109437dbdc) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scripts/EndGame.cs using Guid(faee5c32c5dc44a19b695b109437dbdc) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: '1e54e743ae1e6615ec39cfdd2796e853') in 0.019448 seconds 
========================================================================
Received Import Request.
  Time since last request: 31.236321 seconds.
  path: Assets/Scenes/LostGame.unity
  artifactKey: Guid(6632e07dc5aed4e50a86007ed71d2965) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Scenes/LostGame.unity using Guid(6632e07dc5aed4e50a86007ed71d2965) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'b97ad071499726b8cf6ef496279aa947') in 0.002471 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004403 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.00 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  4.499 seconds
Domain Reload Profiling:
	ReloadAssembly (4509ms)
		BeginReloadAssembly (1029ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (29ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (333ms)
		EndReloadAssembly (3156ms)
			LoadAssemblies (649ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1135ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (168ms)
			SetupLoadedEditorAssemblies (1341ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (29ms)
				SetLoadedEditorAssemblies (2ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (241ms)
				ProcessInitializeOnLoadAttributes (970ms)
				ProcessInitializeOnLoadMethodAttributes (90ms)
				AfterProcessingInitializeOnLoad (8ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (19ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 4.19 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.6 KB). Loaded Objects now: 3569.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 10.178788 ms (FindLiveObjects: 0.638467 ms CreateObjectMapping: 0.506339 ms MarkObjects: 8.656373 ms  DeleteObjects: 0.374556 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004585 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.76 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  3.358 seconds
Domain Reload Profiling:
	ReloadAssembly (3359ms)
		BeginReloadAssembly (659ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (29ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (195ms)
		EndReloadAssembly (2346ms)
			LoadAssemblies (420ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1208ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (131ms)
			SetupLoadedEditorAssemblies (661ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (135ms)
				ProcessInitializeOnLoadAttributes (473ms)
				ProcessInitializeOnLoadMethodAttributes (38ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (8ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 3.11 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3572.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 5.496658 ms (FindLiveObjects: 0.332473 ms CreateObjectMapping: 0.347338 ms MarkObjects: 4.638044 ms  DeleteObjects: 0.176923 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004652 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.21 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  3.218 seconds
Domain Reload Profiling:
	ReloadAssembly (3221ms)
		BeginReloadAssembly (376ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (19ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (127ms)
		EndReloadAssembly (2523ms)
			LoadAssemblies (210ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (1045ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (157ms)
			SetupLoadedEditorAssemblies (952ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (15ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (164ms)
				ProcessInitializeOnLoadAttributes (698ms)
				ProcessInitializeOnLoadMethodAttributes (68ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (16ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 5.32 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3575.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 7.395900 ms (FindLiveObjects: 0.344564 ms CreateObjectMapping: 0.217853 ms MarkObjects: 6.526158 ms  DeleteObjects: 0.304981 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005523 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.74 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.353 seconds
Domain Reload Profiling:
	ReloadAssembly (2355ms)
		BeginReloadAssembly (444ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (21ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (190ms)
		EndReloadAssembly (1700ms)
			LoadAssemblies (185ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (688ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (114ms)
			SetupLoadedEditorAssemblies (635ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (13ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (125ms)
				ProcessInitializeOnLoadAttributes (452ms)
				ProcessInitializeOnLoadMethodAttributes (40ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 1.97 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.4 KB). Loaded Objects now: 3578.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 5.623422 ms (FindLiveObjects: 0.345521 ms CreateObjectMapping: 0.354432 ms MarkObjects: 4.664794 ms  DeleteObjects: 0.256671 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004211 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.93 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.914 seconds
Domain Reload Profiling:
	ReloadAssembly (2916ms)
		BeginReloadAssembly (277ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (95ms)
		EndReloadAssembly (2430ms)
			LoadAssemblies (147ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (872ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (181ms)
			SetupLoadedEditorAssemblies (1015ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (158ms)
				ProcessInitializeOnLoadAttributes (771ms)
				ProcessInitializeOnLoadMethodAttributes (67ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (17ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 3.79 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.6 KB). Loaded Objects now: 3581.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 7.847076 ms (FindLiveObjects: 0.404160 ms CreateObjectMapping: 0.254145 ms MarkObjects: 6.945971 ms  DeleteObjects: 0.240256 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005418 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.75 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.203 seconds
Domain Reload Profiling:
	ReloadAssembly (2205ms)
		BeginReloadAssembly (375ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (14ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (118ms)
		EndReloadAssembly (1619ms)
			LoadAssemblies (215ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (640ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (98ms)
			SetupLoadedEditorAssemblies (647ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (142ms)
				ProcessInitializeOnLoadAttributes (452ms)
				ProcessInitializeOnLoadMethodAttributes (39ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 2.95 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3584.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 5.729225 ms (FindLiveObjects: 0.354343 ms CreateObjectMapping: 0.353703 ms MarkObjects: 4.785753 ms  DeleteObjects: 0.233266 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.005090 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.80 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.935 seconds
Domain Reload Profiling:
	ReloadAssembly (2937ms)
		BeginReloadAssembly (305ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (14ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (107ms)
		EndReloadAssembly (2404ms)
			LoadAssemblies (160ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (891ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (145ms)
			SetupLoadedEditorAssemblies (989ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (20ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (191ms)
				ProcessInitializeOnLoadAttributes (695ms)
				ProcessInitializeOnLoadMethodAttributes (75ms)
				AfterProcessingInitializeOnLoad (5ms)
				EditorAssembliesLoaded (1ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (16ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 4.03 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3587.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 7.569945 ms (FindLiveObjects: 1.039636 ms CreateObjectMapping: 0.571610 ms MarkObjects: 5.769959 ms  DeleteObjects: 0.186219 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004396 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.77 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  2.374 seconds
Domain Reload Profiling:
	ReloadAssembly (2375ms)
		BeginReloadAssembly (321ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (99ms)
		EndReloadAssembly (1839ms)
			LoadAssemblies (171ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (834ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (97ms)
			SetupLoadedEditorAssemblies (675ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (10ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (124ms)
				ProcessInitializeOnLoadAttributes (478ms)
				ProcessInitializeOnLoadMethodAttributes (58ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 1.99 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3590.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 4.946479 ms (FindLiveObjects: 0.328328 ms CreateObjectMapping: 0.152100 ms MarkObjects: 4.109037 ms  DeleteObjects: 0.354761 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004709 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/ninatchernega/Desktop/my game/My project (1)/Library/PackageCache/com.unity.visualscripting@1.8.0/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.95 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  3.076 seconds
Domain Reload Profiling:
	ReloadAssembly (3078ms)
		BeginReloadAssembly (292ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (13ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (103ms)
		EndReloadAssembly (2561ms)
			LoadAssemblies (154ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (926ms)
			ReleaseScriptCaches (3ms)
			RebuildScriptCaches (159ms)
			SetupLoadedEditorAssemblies (1095ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (17ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (2ms)
				BeforeProcessingInitializeOnLoad (190ms)
				ProcessInitializeOnLoadAttributes (811ms)
				ProcessInitializeOnLoadMethodAttributes (70ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (17ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 4.50 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3056 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.6 KB). Loaded Objects now: 3593.
Memory consumption went from 104.6 MB to 104.5 MB.
Total: 7.367993 ms (FindLiveObjects: 0.386344 ms CreateObjectMapping: 0.239084 ms MarkObjects: 6.576555 ms  DeleteObjects: 0.163746 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Compilation succeeded with: 

program_source:19:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD2 = input.POSITION0;
    return output;
}
Compilation succeeded with: 

program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:20:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _Color;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:27:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex0_ST;
    float4 _MainTex1_ST;
    float4 _MainTex2_ST;
    float4 _MainTex3_ST;
    float4 _MainTex4_ST;
    float4 _MainTex5_ST;
    float4 _MainTex6_ST;
    float4 _MainTex7_ST;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 TEXCOORD0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    uint u_xlatu0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    u_xlatu0 = uint(input.TEXCOORD0.z);
    switch(int(int(u_xlatu0))){
        case 0x0:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex0_ST.xy, VGlobals._MainTex0_ST.zw);
            break;
        case 0x1:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex1_ST.xy, VGlobals._MainTex1_ST.zw);
            break;
        case 0x2:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex2_ST.xy, VGlobals._MainTex2_ST.zw);
            break;
        case 0x3:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex3_ST.xy, VGlobals._MainTex3_ST.zw);
            break;
        case 0x4:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex4_ST.xy, VGlobals._MainTex4_ST.zw);
            break;
        case 0x5:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex5_ST.xy, VGlobals._MainTex5_ST.zw);
            break;
        case 0x6:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex6_ST.xy, VGlobals._MainTex6_ST.zw);
            break;
        case 0x7:
            u_xlat0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex7_ST.xy, VGlobals._MainTex7_ST.zw);
            break;
        default:
            u_xlat0.x = float(0.0);
            u_xlat0.y = float(0.0);
            break;
        }
        output.TEXCOORD0.xy = u_xlat0.xy;
        output.COLOR0 = input.COLOR0;
        output.TEXCOORD0.z = input.TEXCOORD0.z;
        return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float3 TEXCOORD1 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    u_xlat2.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[0].xyz, u_xlat0.xxx, u_xlat2.xyz);
    output.TEXCOORD0.zw = u_xlat1.zz + u_xlat1.xw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    output.TEXCOORD1.xyz = input.TEXCOORD1.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz);
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[2].xyz;
    u_xlat0.xyz = u_xlat0.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.xyz = u_xlat1.xyz + VGlobals.hlslcc_mtx4x4unity_CameraInvProjection[3].xyz;
    u_xlat1.w = (-u_xlat1.z);
    output.TEXCOORD2.xyz = u_xlat1.xyw;
    u_xlat0.w = (-u_xlat0.z);
    output.TEXCOORD3.xyz = u_xlat0.xyw;
    return output;
}
Compilation succeeded with: 

program_source:26:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _Color;
    float4 _ClipRect;
    float4 _MainTex_ST;
    float _UIMaskSoftnessX;
    float _UIMaskSoftnessY;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    output.COLOR0 = input.COLOR0 * VGlobals._Color;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1 = input.POSITION0;
    u_xlat0.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat0.xy);
    u_xlat0.xy = u_xlat0.ww / abs(u_xlat0.xy);
    u_xlat0.xy = fma(float2(VGlobals._UIMaskSoftnessX, VGlobals._UIMaskSoftnessY), float2(0.25, 0.25), abs(u_xlat0.xy));
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat0.xy;
    u_xlat0 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat0 = min(u_xlat0, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat0.xy = fma(input.POSITION0.xy, float2(2.0, 2.0), (-u_xlat0.xy));
    output.TEXCOORD2.xy = (-u_xlat0.zw) + u_xlat0.xy;
    return output;
}
Compilation succeeded with: 

program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
program_source:30:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    float _UVSec;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.mtl_Position = u_xlat0;
    u_xlatb1 = VGlobals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = fma(u_xlat1.xy, VGlobals._DetailAlbedoMap_ST.xy, VGlobals._DetailAlbedoMap_ST.zw);
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    output.TEXCOORD1.w = 0.0;
    u_xlat1.xyz = input.POSITION0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.POSITION0.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.POSITION0.zzz, u_xlat1.xyz);
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz + (-VGlobals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.w = 0.0;
    output.TEXCOORD2 = u_xlat1.wwwx;
    output.TEXCOORD3 = u_xlat1.wwwy;
    output.TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat1.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = fma(u_xlat1.x, u_xlat1.x, (-u_xlat10));
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(VGlobals.unity_SHBr, u_xlat2);
    u_xlat1.y = dot(VGlobals.unity_SHBg, u_xlat2);
    u_xlat1.z = dot(VGlobals.unity_SHBb, u_xlat2);
    output.TEXCOORD5.xyz = fma(VGlobals.unity_SHC.xyz, float3(u_xlat10), u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * VGlobals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD7.zw = u_xlat0.zw;
    output.TEXCOORD7.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}
Compilation succeeded with: 

program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
program_source:21:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], input.POSITION0.wwww, u_xlat1);
    u_xlat2.xyz = fma((-u_xlat1.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = fma((-u_xlat9), u_xlat9, 1.0);
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * VGlobals.unity_LightShadowBias.z;
    u_xlat0.xyz = fma((-u_xlat0.xyz), float3(u_xlat9), u_xlat1.xyz);
    u_xlatb9 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat2);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat0);
    u_xlat1.x = VGlobals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat0.x, u_xlat6);
    return output;
}
Compilation succeeded with: 

program_source:23:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _LightColor0;
    float _Exposure;
    float3 _GroundColor;
    float3 _SkyTint;
    float _AtmosphereThickness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float4 u_xlat5;
    float3 u_xlat6;
    float u_xlat7;
    float3 u_xlat9;
    float u_xlat14;
    float2 u_xlat16;
    float u_xlat21;
    float u_xlat22;
    float u_xlat23;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat1 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat2 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat2);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat2);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat1.wwww, u_xlat2);
    u_xlat1.xyz = (-VGlobals._SkyTint.xyzx.xyz) + float3(1.0, 1.0, 1.0);
    u_xlat1.xyz = fma(u_xlat1.xyz, float3(0.300000012, 0.300000042, 0.300000012), float3(0.5, 0.419999987, 0.324999988));
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat1.xyz;
    u_xlat1.xyz = float3(1.0, 1.0, 1.0) / u_xlat1.xyz;
    u_xlat21 = log2(VGlobals._AtmosphereThickness);
    u_xlat21 = u_xlat21 * 2.5;
    u_xlat21 = exp2(u_xlat21);
    u_xlat2.xy = float2(u_xlat21) * float2(0.049999997, 0.0314159282);
    u_xlat21 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat3.xyz = float3(u_xlat21) * u_xlat0.xyz;
    u_xlatb0 = u_xlat3.y>=0.0;
    if(u_xlatb0){
        u_xlat0.x = fma(u_xlat3.y, u_xlat3.y, 0.0506249666);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = fma((-u_xlat0.y), u_xlat21, u_xlat0.x);
        u_xlat7 = fma((-u_xlat3.y), 1.0, 1.0);
        u_xlat14 = fma(u_xlat7, 5.25, -6.80000019);
        u_xlat14 = fma(u_xlat7, u_xlat14, 3.82999992);
        u_xlat14 = fma(u_xlat7, u_xlat14, 0.458999991);
        u_xlat7 = fma(u_xlat7, u_xlat14, -0.00286999997);
        u_xlat7 = u_xlat7 * 1.44269502;
        u_xlat0.y = exp2(u_xlat7);
        u_xlat0.xyz = u_xlat0.xyx * float3(0.5, 0.246031836, 20.0);
        u_xlat4.xyz = u_xlat0.xxx * u_xlat3.xyz;
        u_xlat4.xyz = fma(u_xlat4.xyz, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat22 = (-u_xlat21) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat21;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat21 = u_xlat23 / u_xlat21;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat23 = fma(u_xlat21, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat21, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat21, u_xlat23, 0.458999991);
        u_xlat21 = fma(u_xlat21, u_xlat23, -0.00286999997);
        u_xlat21 = u_xlat21 * 1.44269502;
        u_xlat21 = exp2(u_xlat21);
        u_xlat21 = u_xlat21 * 0.25;
        u_xlat21 = fma(u_xlat16.x, 0.25, (-u_xlat21));
        u_xlat21 = fma(u_xlat22, u_xlat21, u_xlat0.y);
        u_xlat21 = max(u_xlat21, 0.0);
        u_xlat21 = min(u_xlat21, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat6.xyz = (-float3(u_xlat21)) * u_xlat5.xyz;
        u_xlat6.xyz = u_xlat6.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat6.xyz = exp2(u_xlat6.xyz);
        u_xlat21 = u_xlat0.z * u_xlat22;
        u_xlat4.xyz = fma(u_xlat3.xyz, u_xlat0.xxx, u_xlat4.xyz);
        u_xlat0.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat22 = (-u_xlat0.x) + 1.0;
        u_xlat22 = u_xlat22 * 230.831207;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat4.xyz);
        u_xlat16.x = u_xlat16.x / u_xlat0.x;
        u_xlat23 = dot(u_xlat3.xyz, u_xlat4.xyz);
        u_xlat0.x = u_xlat23 / u_xlat0.x;
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat0.x = (-u_xlat0.x) + 1.0;
        u_xlat23 = fma(u_xlat0.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat0.x, u_xlat23, 0.458999991);
        u_xlat0.x = fma(u_xlat0.x, u_xlat23, -0.00286999997);
        u_xlat0.x = u_xlat0.x * 1.44269502;
        u_xlat0.x = exp2(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * 0.25;
        u_xlat0.x = fma(u_xlat16.x, 0.25, (-u_xlat0.x));
        u_xlat0.x = fma(u_xlat22, u_xlat0.x, u_xlat0.y);
        u_xlat0.x = max(u_xlat0.x, 0.0);
        u_xlat0.x = min(u_xlat0.x, 50.0);
        u_xlat4.xyz = u_xlat5.xyz * (-u_xlat0.xxx);
        u_xlat4.xyz = u_xlat4.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat4.xyz = exp2(u_xlat4.xyz);
        u_xlat0.x = u_xlat0.z * u_xlat22;
        u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
        u_xlat0.xyz = fma(u_xlat6.xyz, float3(u_xlat21), u_xlat0.xyz);
        u_xlat4.xyz = u_xlat1.xyz * u_xlat2.xxx;
        u_xlat4.xyz = u_xlat0.xyz * u_xlat4.xyz;
        u_xlat0.xyz = u_xlat0.xyz * float3(0.0199999996, 0.0199999996, 0.0199999996);
    } else {
        u_xlat21 = min(u_xlat3.y, -0.00100000005);
        u_xlat21 = -9.99999975e-05 / u_xlat21;
        u_xlat5.xyz = fma(float3(u_xlat21), u_xlat3.xyz, float3(0.0, 1.00010002, 0.0));
        u_xlat22 = dot((-u_xlat3.xyz), u_xlat5.xyz);
        u_xlat16.x = dot(VGlobals._WorldSpaceLightPos0.xyz, u_xlat5.xyz);
        u_xlat22 = (-u_xlat22) + 1.0;
        u_xlat23 = fma(u_xlat22, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat22, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat22, u_xlat23, 0.458999991);
        u_xlat22 = fma(u_xlat22, u_xlat23, -0.00286999997);
        u_xlat22 = u_xlat22 * 1.44269502;
        u_xlat22 = exp2(u_xlat22);
        u_xlat16.x = (-u_xlat16.x) + 1.0;
        u_xlat23 = fma(u_xlat16.x, 5.25, -6.80000019);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 3.82999992);
        u_xlat23 = fma(u_xlat16.x, u_xlat23, 0.458999991);
        u_xlat16.x = fma(u_xlat16.x, u_xlat23, -0.00286999997);
        u_xlat16.x = u_xlat16.x * 1.44269502;
        u_xlat16.x = exp2(u_xlat16.x);
        u_xlat5.xy = float2(u_xlat22) * float2(0.25, 0.249900013);
        u_xlat22 = fma(u_xlat16.x, 0.25, u_xlat5.x);
        u_xlat16.xy = float2(u_xlat21) * float2(0.5, 20.0);
        u_xlat5.xzw = u_xlat16.xxx * u_xlat3.xyz;
        u_xlat5.xzw = fma(u_xlat5.xzw, float3(0.5, 0.5, 0.5), float3(0.0, 1.00010002, 0.0));
        u_xlat21 = dot(u_xlat5.xzw, u_xlat5.xzw);
        u_xlat21 = sqrt(u_xlat21);
        u_xlat21 = (-u_xlat21) + 1.0;
        u_xlat21 = u_xlat21 * 230.831207;
        u_xlat21 = exp2(u_xlat21);
        u_xlat22 = fma(u_xlat21, u_xlat22, (-u_xlat5.y));
        u_xlat22 = max(u_xlat22, 0.0);
        u_xlat22 = min(u_xlat22, 50.0);
        u_xlat5.xyz = fma(u_xlat1.xyz, u_xlat2.yyy, float3(0.0125663709, 0.0125663709, 0.0125663709));
        u_xlat5.xyz = (-float3(u_xlat22)) * u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz * float3(1.44269502, 1.44269502, 1.44269502);
        u_xlat0.xyz = exp2(u_xlat5.xyz);
        u_xlat21 = u_xlat16.y * u_xlat21;
        u_xlat9.xyz = float3(u_xlat21) * u_xlat0.xyz;
        u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat2.xxx, float3(0.0199999996, 0.0199999996, 0.0199999996));
        u_xlat4.xyz = u_xlat1.xyz * u_xlat9.xyz;
    }
    u_xlat1.xyz = VGlobals._GroundColor.xxyz.yzw * VGlobals._GroundColor.xxyz.yzw;
    u_xlat1.xyz = fma(u_xlat1.xyz, u_xlat0.xyz, u_xlat4.xyz);
    output.TEXCOORD1.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._WorldSpaceLightPos0.xyz, (-u_xlat3.xyz));
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat21 = fma(u_xlat21, 0.75, 0.75);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat4.xyz;
    output.TEXCOORD2.xyz = u_xlat1.xyz * float3(VGlobals._Exposure);
    u_xlat21 = dot(VGlobals._LightColor0.xyz, VGlobals._LightColor0.xyz);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = max(u_xlat21, 0.25);
    u_xlat21 = min(u_xlat21, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * float3(8000.0, 8000.0, 8000.0);
    u_xlat0.xyz = clamp(u_xlat0.xyz, 0.0f, 1.0f);
    u_xlat0.xyz = u_xlat0.xyz * VGlobals._LightColor0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * float3(27.0, 27.0, 27.0);
    output.TEXCOORD3.xyz = u_xlat0.xyz / float3(u_xlat21);
    output.TEXCOORD0.xyz = (-u_xlat3.xyz);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
program_source:22:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 hlslcc_mtx4x4unity_GUIClipTextureMatrix[4];
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float2 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float2 u_xlat2;
    u_xlat0 = input.POSITION0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], input.POSITION0.xxxx, u_xlat0);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat0);
    u_xlat0 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat0.wwww, u_xlat1);
    output.COLOR0 = input.COLOR0;
    u_xlat1.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_MatrixV[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[0].xy, u_xlat0.xx, u_xlat1.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[2].xy, u_xlat0.zz, u_xlat0.xy);
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_MatrixV[3].xy, u_xlat0.ww, u_xlat0.xy);
    u_xlat2.xy = u_xlat0.yy * VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[1].xy;
    u_xlat0.xy = fma(VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[0].xy, u_xlat0.xx, u_xlat2.xy);
    output.TEXCOORD1.xy = u_xlat0.xy + VGlobals.hlslcc_mtx4x4unity_GUIClipTextureMatrix[3].xy;
    output.TEXCOORD0.xy = fma(input.TEXCOORD0.xy, VGlobals._MainTex_ST.xy, VGlobals._MainTex_ST.zw);
    return output;
}
Compilation succeeded with: 

program_source:29:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float _FontTexSDFScale;
    float4 _ShaderInfoTex_TexelSize;
    float4 _TextureInfo[8];
    float4 _ClipSpaceParams;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 COLOR0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float4 TEXCOORD1 [[ attribute(3) ]] ;
    float4 TEXCOORD2 [[ attribute(4) ]] ;
    float4 TEXCOORD3 [[ attribute(5) ]] ;
    float4 TEXCOORD4 [[ attribute(6) ]] ;
    float4 TEXCOORD5 [[ attribute(7) ]] ;
    float TEXCOORD6 [[ attribute(8) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float2 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_ShaderInfoTex [[ sampler (0) ]],
    texture2d<float, access::sample > _ShaderInfoTex [[ texture(0) ]] ,
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    int u_xlati0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool4 u_xlatb1;
    float4 u_xlat2;
    bool2 u_xlatb2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    bool4 u_xlatb6;
    float4 u_xlat7;
    float3 u_xlat8;
    float3 u_xlat9;
    uint u_xlatu9;
    float3 u_xlat10;
    float u_xlat16;
    uint u_xlatu18;
    bool u_xlatb18;
    float2 u_xlat20;
    u_xlat0 = input.TEXCOORD2.xzwy * float4(255.0, 255.0, 255.0, 255.0);
    u_xlat0 = rint(u_xlat0);
    u_xlat1 = u_xlat0 * float4(32.0, 32.0, 32.0, 32.0);
    u_xlatb1 = (u_xlat1>=(-u_xlat1));
    u_xlat2.x = (u_xlatb1.x) ? float(32.0) : float(-32.0);
    u_xlat2.y = (u_xlatb1.x) ? float(0.03125) : float(-0.03125);
    u_xlat2.z = (u_xlatb1.y) ? float(32.0) : float(-32.0);
    u_xlat2.w = (u_xlatb1.y) ? float(0.03125) : float(-0.03125);
    u_xlat1.xy = u_xlat0.xy * u_xlat2.yw;
    u_xlat1.xy = fract(u_xlat1.xy);
    u_xlat10.xz = u_xlat1.xy * u_xlat2.xz;
    u_xlat0.xy = fma((-u_xlat2.xz), u_xlat1.xy, u_xlat0.xy);
    u_xlat1.x = fma(input.TEXCOORD1.x, 8160.0, u_xlat10.x);
    u_xlat0.xy = u_xlat0.xy * float2(0.09375, 0.03125);
    u_xlat1.y = fma(input.TEXCOORD1.y, 2040.0, u_xlat0.x);
    u_xlat3 = u_xlat1.xyxy + float4(0.5, 0.5, 0.5, 1.5);
    u_xlat3 = u_xlat3 * VGlobals._ShaderInfoTex_TexelSize.xyxy;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 2.5);
    u_xlat1.xy = u_xlat1.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat4 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.xy, level(0.0));
    u_xlat3 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat3.zw, level(0.0));
    u_xlat5 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat1.xy, level(0.0));
    u_xlat0.x = input.TEXCOORD3.x * 255.0;
    u_xlat0.x = rint(u_xlat0.x);
    u_xlatb6 = (u_xlat0.xxxx==float4(4.0, 3.0, 2.0, 1.0));
    u_xlat7 = select(float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), bool4(u_xlatb6));
    u_xlat1.xy = u_xlat7.zz + u_xlat7.wy;
    u_xlat0.x = u_xlat7.y + u_xlat1.x;
    u_xlat0.x = u_xlat7.x + u_xlat0.x;
    u_xlat0.x = min(u_xlat0.x, 1.0);
    u_xlat0.x = (-u_xlat0.x) + 1.0;
    u_xlat20.x = dot(u_xlat4, input.POSITION0);
    u_xlat20.y = dot(u_xlat3, input.POSITION0);
    u_xlat1.x = dot(u_xlat5, input.POSITION0);
    u_xlat3 = u_xlat20.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat20.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat1.xxxx, u_xlat3);
    u_xlat3 = u_xlat3 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat5 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat5);
    u_xlat5 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat5);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat5);
    u_xlatb1.x = VGlobals._FontTexSDFScale==0.0;
    u_xlatb1.x = u_xlatb1.x && u_xlatb6.w;
    u_xlat2.xy = u_xlat3.xy + float2(1.0, 1.0);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.xy, float2(0.152700007, 0.152700007));
    u_xlat2.xy = rint(u_xlat2.xy);
    u_xlat2.xy = fma(u_xlat2.xy, VGlobals._ClipSpaceParams.zw, float2(-1.0, -1.0));
    output.mtl_Position.xy = (u_xlatb1.x) ? u_xlat2.xy : u_xlat3.xy;
    u_xlat2.xy = select(float2(0.0, 0.0), float2(2.0, 4.0), bool2(u_xlatb6.wx));
    u_xlat0.x = u_xlat0.x + u_xlat2.x;
    u_xlat0.x = fma(u_xlat1.y, 3.0, u_xlat0.x);
    output.TEXCOORD1.x = u_xlat2.y + u_xlat0.x;
    u_xlat1.y = 0.0;
    u_xlat2.x = float(0.0);
    u_xlat2.y = float(0.0);
    u_xlati0 = 0x0;
    while(true){
        u_xlatb18 = u_xlat2.y>=7.0;
        u_xlati0 = 0x0;
        if(u_xlatb18){break;}
        u_xlatu18 = uint(u_xlat2.y);
        u_xlatb18 = input.TEXCOORD6==VGlobals._TextureInfo[int(u_xlatu18)].x;
        if(u_xlatb18){
            u_xlat2.x = u_xlat2.y;
            u_xlati0 = int(0xffffffffu);
            break;
        }
        u_xlat1.x = u_xlat2.y + 1.0;
        u_xlat2.xy = u_xlat1.yx;
        u_xlatb0 = u_xlatb18;
    }
    u_xlat0.x = (u_xlati0 != 0) ? u_xlat2.x : 7.0;
    u_xlat1.x = dot(input.TEXCOORD4.zw, float2(65025.0, 255.0));
    u_xlatb2.xy = (float2(0.0, 0.0)<input.TEXCOORD3.zw);
    u_xlat9.x = u_xlatb2.x ? 1.0 : float(0.0);
    u_xlat2.x = (u_xlatb2.x) ? 3.0 : 2.0;
    output.TEXCOORD1.w = (u_xlatb2.y) ? u_xlat2.x : u_xlat9.x;
    if(u_xlatb6.y){
        u_xlatu9 = uint(u_xlat0.x);
        output.TEXCOORD0.xy = input.TEXCOORD0.xy * VGlobals._TextureInfo[int(u_xlatu9)].yz;
    } else {
        output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    }
    u_xlat3.x = fma(input.TEXCOORD4.x, 8160.0, u_xlat10.z);
    u_xlat3.y = fma(input.TEXCOORD4.y, 2040.0, u_xlat0.y);
    u_xlat2.xz = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat2.xz = u_xlat2.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat5.x = (u_xlatb1.z) ? float(32.0) : float(-32.0);
    u_xlat5.y = (u_xlatb1.z) ? float(0.03125) : float(-0.03125);
    u_xlat5.z = (u_xlatb1.w) ? float(32.0) : float(-32.0);
    u_xlat5.w = (u_xlatb1.w) ? float(0.03125) : float(-0.03125);
    u_xlat9.xyz = u_xlat0.zwz * u_xlat5.ywy;
    u_xlat9.xyz = fract(u_xlat9.xyz);
    u_xlat3.xy = u_xlat9.yz * u_xlat5.zx;
    u_xlat8.xyz = fma((-u_xlat5.xzx), u_xlat9.xyz, u_xlat0.zwz);
    u_xlat8.xyz = u_xlat8.xyz * float3(0.03125, 0.03125, 0.125);
    u_xlat5.x = fma(input.TEXCOORD4.z, 8160.0, u_xlat3.y);
    u_xlat5.yz = fma(input.TEXCOORD4.ww, float2(2040.0, 2040.0), u_xlat8.xz);
    u_xlat8.xz = u_xlat5.xy + float2(0.5, 0.5);
    u_xlat8.xz = u_xlat8.xz * VGlobals._ShaderInfoTex_TexelSize.xy;
    if(u_xlatb2.y){
        u_xlat7 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat8.xz, level(0.0)).wxyz;
        output.COLOR0.xyz = u_xlat7.yzw;
    } else {
        output.COLOR0.xyz = input.COLOR0.xyz;
        u_xlat7.x = input.COLOR0.w;
    }
    u_xlat3.x = fma(input.TEXCOORD1.z, 8160.0, u_xlat3.x);
    u_xlat3.y = fma(input.TEXCOORD1.w, 2040.0, u_xlat8.y);
    u_xlat9.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat9.xy = u_xlat9.xy * VGlobals._ShaderInfoTex_TexelSize.xy;
    u_xlat16 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat2.xz, level(0.0)).w;
    output.COLOR0.w = u_xlat16 * u_xlat7.x;
    output.TEXCOORD1.z = (u_xlatb6.w) ? u_xlat16 : u_xlat1.x;
    output.TEXCOORD3.xy = (u_xlatb6.w) ? u_xlat5.xz : u_xlat8.xz;
    u_xlat1 = _ShaderInfoTex.sample(sampler_ShaderInfoTex, u_xlat9.xy, level(0.0));
    output.TEXCOORD0.zw = fma(u_xlat20.xy, u_xlat1.xy, u_xlat1.zw);
    output.TEXCOORD4.x = (u_xlatb6.w) ? input.TEXCOORD3.y : input.TEXCOORD5.x;
    output.mtl_Position.zw = u_xlat3.zw;
    output.TEXCOORD1.y = u_xlat0.x;
    output.TEXCOORD4.yzw = input.TEXCOORD5.yzw;
    return output;
}
Compilation succeeded with: 

program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
program_source:43:38: warning: unknown attribute 'invariant' ignored
    float4 mtl_Position [[ position, invariant ]];
                                     ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct VGlobals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ScreenParams;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _FaceColor;
    float _FaceDilate;
    float _OutlineSoftness;
    float4 _OutlineColor;
    float _OutlineWidth;
    float _WeightNormal;
    float _WeightBold;
    float _ScaleRatioA;
    float _VertexOffsetX;
    float _VertexOffsetY;
    float4 _ClipRect;
    float _MaskSoftnessX;
    float _MaskSoftnessY;
    float _GradientScale;
    float _ScaleX;
    float _ScaleY;
    float _PerspectiveFilter;
    float _Sharpness;
};
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
    float4 COLOR0 [[ attribute(2) ]] ;
    float2 TEXCOORD0 [[ attribute(3) ]] ;
    float2 TEXCOORD1 [[ attribute(4) ]] ;
};
struct Mtl_VertexOut
{
    float4 mtl_Position [[ position, invariant ]];
    float4 COLOR0 [[ user(COLOR0) ]];
    float4 COLOR1 [[ user(COLOR1) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
};
vertex Mtl_VertexOut xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float2 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float u_xlat4;
    float2 u_xlat5;
    float u_xlat8;
    float u_xlat9;
    float u_xlat12;
    bool u_xlatb12;
    u_xlat0.xy = input.POSITION0.xy + float2(VGlobals._VertexOffsetX, VGlobals._VertexOffsetY);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], input.POSITION0.zzzz, u_xlat1);
    u_xlat2 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.POSITION0.www, u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) + VGlobals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat3 = u_xlat2.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat2.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat2.zzzz, u_xlat3);
    u_xlat2 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat2.wwww, u_xlat3);
    output.mtl_Position = u_xlat2;
    u_xlat3 = input.COLOR0 * VGlobals._FaceColor;
    u_xlat3.xyz = u_xlat3.www * u_xlat3.xyz;
    output.COLOR0 = u_xlat3;
    u_xlat8 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat1.xyz = float3(u_xlat8) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat8 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat8 = rsqrt(u_xlat8);
    u_xlat2.xyz = float3(u_xlat8) * u_xlat2.xyz;
    u_xlat8 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat1.xy = VGlobals._ScreenParams.yy * VGlobals.hlslcc_mtx4x4glstate_matrix_projection[1].xy;
    u_xlat1.xy = fma(VGlobals.hlslcc_mtx4x4glstate_matrix_projection[0].xy, VGlobals._ScreenParams.xx, u_xlat1.xy);
    u_xlat1.xy = abs(u_xlat1.xy) * float2(VGlobals._ScaleX, VGlobals._ScaleY);
    u_xlat1.xy = u_xlat2.ww / u_xlat1.xy;
    u_xlat12 = dot(u_xlat1.xy, u_xlat1.xy);
    u_xlat1.xy = fma(float2(VGlobals._MaskSoftnessX, VGlobals._MaskSoftnessY), float2(0.25, 0.25), u_xlat1.xy);
    output.TEXCOORD2.zw = float2(0.25, 0.25) / u_xlat1.xy;
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.x = abs(input.TEXCOORD1.y) * VGlobals._GradientScale;
    u_xlat5.x = VGlobals._Sharpness + 1.0;
    u_xlat1.x = u_xlat5.x * u_xlat1.x;
    u_xlat5.x = u_xlat12 * u_xlat1.x;
    u_xlat9 = (-VGlobals._PerspectiveFilter) + 1.0;
    u_xlat9 = u_xlat9 * abs(u_xlat5.x);
    u_xlat12 = fma(u_xlat12, u_xlat1.x, (-u_xlat9));
    u_xlat8 = fma(abs(u_xlat8), u_xlat12, u_xlat9);
    u_xlatb12 = VGlobals.hlslcc_mtx4x4glstate_matrix_projection[3].w==0.0;
    u_xlat8 = (u_xlatb12) ? u_xlat8 : u_xlat5.x;
    u_xlat12 = VGlobals._OutlineSoftness * VGlobals._ScaleRatioA;
    u_xlat12 = fma(u_xlat12, u_xlat8, 1.0);
    u_xlat1.x = u_xlat8 / u_xlat12;
    u_xlat8 = VGlobals._OutlineWidth * VGlobals._ScaleRatioA;
    u_xlat8 = u_xlat1.x * u_xlat8;
    u_xlat12 = min(u_xlat8, 1.0);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat2.w = input.COLOR0.w * VGlobals._OutlineColor.w;
    u_xlat2.xyz = u_xlat2.www * VGlobals._OutlineColor.xyz;
    u_xlat2 = (-u_xlat3) + u_xlat2;
    output.COLOR1 = fma(float4(u_xlat12), u_xlat2, u_xlat3);
    u_xlat2 = max(VGlobals._ClipRect, float4(-2e+10, -2e+10, -2e+10, -2e+10));
    u_xlat2 = min(u_xlat2, float4(2e+10, 2e+10, 2e+10, 2e+10));
    u_xlat5.xy = u_xlat0.xy + (-u_xlat2.xy);
    u_xlat0.xy = fma(u_xlat0.xy, float2(2.0, 2.0), (-u_xlat2.xy));
    output.TEXCOORD2.xy = (-u_xlat2.zw) + u_xlat0.xy;
    u_xlat0.xy = (-u_xlat2.xy) + u_xlat2.zw;
    output.TEXCOORD0.zw = u_xlat5.xy / u_xlat0.xy;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy;
    u_xlatb0 = 0.0>=input.TEXCOORD1.y;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat4 = (-VGlobals._WeightNormal) + VGlobals._WeightBold;
    u_xlat0.x = fma(u_xlat0.x, u_xlat4, VGlobals._WeightNormal);
    u_xlat0.x = fma(u_xlat0.x, 0.25, VGlobals._FaceDilate);
    u_xlat0.x = u_xlat0.x * VGlobals._ScaleRatioA;
    u_xlat0.x = fma((-u_xlat0.x), 0.5, 0.5);
    u_xlat1.w = fma(u_xlat0.x, u_xlat1.x, -0.5);
    output.TEXCOORD1.xw = u_xlat1.xw;
    output.TEXCOORD1.y = fma((-u_xlat8), 0.5, u_xlat1.w);
    output.TEXCOORD1.z = fma(u_xlat8, 0.5, u_xlat1.w);
    return output;
}
Refreshing native plugins compatible for Editor in 4.62 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 17 Unused Serialized files (Serialized files now loaded: 0)
Unloading 17 unused Assets / (68.5 KB). Loaded Objects now: 3593.
Memory consumption went from 43.8 MB to 43.7 MB.
Total: 64.885731 ms (FindLiveObjects: 5.075619 ms CreateObjectMapping: 0.319567 ms MarkObjects: 59.246712 ms  DeleteObjects: 0.239857 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
